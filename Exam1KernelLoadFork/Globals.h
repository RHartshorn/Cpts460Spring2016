//******************************************************************
//Author: Robin Hartshorn
//Student ID: 10906124
//Date Created: 2/5/16
//Last Edited: 3/29/16
//Project: Computer Science 460: Exam 1
//******************************************************************

#ifndef TS_H
#define TS_H

#define MAXPATHNAMELEN 64
#define MAXLEN         1024
#define MAXLENPATH     64
#define BLKSIZE        1025

//IO
#define BASE8   8
#define BASE10 10
#define BASE16 16

//PROC
#define FREE    0
#define READY   1
#define SLEEP   2
#define BLOCK   3
#define ZOMBIE  4
#define RUNNING 5

//PIPE
#define READ         0
#define WRITE        1
#define READ_PIPE    2
#define WRITE_PIPE   3

#define NPROC 9                // number of PROCs
#define SSIZE 1024             // per proc stack area 

#define PSIZE 10
#define NPIPE 20
#define NOFT  20
#define NFD   20

typedef unsigned short u16;
typedef unsigned long u32;
typedef unsigned char u8;

typedef struct pipe{
    char buf[PSIZE];
    int head, tail; 
    int data, room;
    int nreader, nwriter;       //number of readers, writers
    int status;                 //IN_USE or FREE
}PIPE;

//open file table
typedef struct oft{
    int mode;
    int refCount;

    PIPE *pipe_ptr;

    //these are for regular files and are not used for pipes
    //INODE *inodeptr;
    //long offset // Ordinary file
}OFT;

//dont move around ksp next or kstack
typedef struct proc{
    struct proc *next;
    int    *ksp;               // at offset 2 //kernal stack space 

    int    uss;                // user stack space // what segment the users stack is in
    int    usp;                // user stack pointer

    int    inkmode;            // at offset 8 // in k mode

    int    pid;                // add pid for identify the proc
    int    status;             // status = FREE|READY|RUNNING|SLEEP|ZOMBIE    
    int    ppid;               // parent pid
    struct proc *parent;
    int    priority;
    int    event;
    int    exitCode;
    char   name[32];           // name string of PROC

    OFT    *fd[NFD];           // open file discriptor

    int    kstack[SSIZE];      // per proc stack area
}PROC;

//a.out files generated by bcc have a 32-bit header containing
// 8 longs(u32)
typedef struct header
{
    u32 ID_space;               //ox04100301: combined I&D
                                //or 0x04200301: seperate I&D
                                //will always be 0x04200301 (single seg model) 
    u32 magic_number;           //0x00000020    
    u32 tsize;                  //code section size in bytes
    u32 dsize;                  //initialized data section 
                                //size in bytes
    u32 bsize;                  //bss section size in bytes
    u32 zero;                   //0
    u32 total_size;             //total memory size, including heap
    u32 symbolTable_size;       //only if symbol table is present
}HEADER;

extern int color;

char *statusArray[] = {"FREE", "READY", "SLEEP", "BLOCK", "ZOMBIE", "RUNNING"};
char *pipeModeArray[] = {"READ", "WRITE", "READ_PIPE", "WRITE_PIPE"};


char *pname[] = {"Sun", "Mercury", "Venus", 
                 "Earth",  "Mars", "Jupiter", 
                 "Saturn", "Uranus", "Neptune"};

//IO
char *ascciTable = "0123456789ABCDEF";

char LoadBuf[BLKSIZE];
char LoadBuf2[BLKSIZE];
char LoadBuf3[BLKSIZE];

//Globals ************
PROC *running;              //current executing PROC
PROC *freeList;             //list of FREE PROCs
PROC *readyQueue;           //priority queue of READY PROCs
PROC *sleepQueue;

char FilePathArray[MAXLENPATH];

PROC proc[NPROC];

//for PIPE **********
PIPE pipe[NPIPE];
OFT oft[NOFT];

int  procSize = sizeof(PROC);

#endif

